# 4 - 光线追踪

计算机图形学的基本任务之一是绘制三维物体：取一个由许多几何物体组成的场景，并计算从特定视点显示物体的二维图像。

从根本上说，渲染是一个将一组对象作为输入并产生一组像素作为输出的过程。如果输出的是矢量图像而不是光栅图像，渲染不一定要涉及像素，但我们将在本书中假设栅格图像。

考虑到每个对象对每个像素的贡献，它可以以两种一般方式组织：

```cpp
for every object:
	calculate what pix does it contribute to

for every pix:
	calculate what object does it hit, and how these object look like
```

以图像为顺序的渲染器和以对象为顺序的渲染器可以计算完全相同的图像，但是它们可以计算不同类型的效果，并且具有完全不同的性能特征。但是，从广义上讲，图像顺序渲染更容易工作，在可以产生的效果中更灵活，并且通常需要更多的执行时间来产生图像。

> 在光线追踪器中，很容易计算出准确的阴影和反射，这在对象顺序框架中是很难的。

## 4.1 基本光追算法

光追算法的工作原理是一次计算一个像素，对于每个像素，基本任务是找到在图像中该像素位置处看到的对象。每个像素向不同的方向看，像素看到的任何对象都必须与观察光线相交，这是一条从视点发出的线，从像素正在观看的方向发出。我们想要的特定对象是与距离相机最近的观察光线相交的对象，因为它遮挡了后面任何其他对象的视图。一旦找到该对象，着色计算就使用交叉点、表面法线、和其他信息(取决于所需的渲染类型)来确定像素的颜色。光追算法简述：

1. 生成射线，基于摄像机的位置和旋转生成每个像素方向的射线
2. 射线求交，找到射线击中的最接近几何体
3. 着色，根据交点上的性质求出像素的颜色

![](pic/Pasted%20image%2020240229204518.png)

## 4.2 透视

早在计算机数百年前，艺术家们就研究了用 2D 图形来表示 3D 对象或场景的问题。照片也用 2D 图像表示 3D 场景。虽然有许多非传统的成像方法，从立体绘画到鱼眼镜头再到外围相机，但艺术和摄影以及计算机图形学的标准方法都是**线性透视**，即 3D 对象被投影到像平面上，使得场景中的直线变成图像中的直线。

最简单的投影类型是平行投影（正交投影），将三维点沿投影方向移动到二维空间，直到它们到达图像平面。所产生的视点由投影方向和图像平面的组合决定。如果图像平面垂直于观察方向，则该投影称为**正投影**；否则称**斜投影**。
![](pic/Pasted%20image%2020240229205241.png)
平行投影法常用于机械和建筑图纸，因为它们保持平行线平行，并保持与图像平面平行的平面物体的大小和形状。
平行投影的优点也是它的局限性。在我们的日常经验中，物体越远看起来越小，结果，平行线向远处延伸时看起来并不平行，这是因为眼睛和照相机不能从单一的观察方向收集光线，它们收集通过特定视点的光线。正如文艺复兴时期以来的艺术家们所认识到的那样，我们可以使用透视投影来制作自然的视图：我们只是沿着穿过单个点（视点）的线进行投影，而不是沿着平行线进行投影。这样，离视点越远的物体在投影时自然越小。

透视图（透视投影）由视点的选择和图像平面决定（而不是投影方向）。与正交投影一样，透视投影也有倾斜和非倾斜透视图，这种区别在于投影方向是否在图像的中心。
![](pic/Pasted%20image%2020240229205928.png)
你可能已经了解了三点透视的艺术规则：一种人工构建透视图的系统。
关于透视法的一个令人惊讶的事实是，如果我们遵循透视法背后的简单数学规则，那么透视图的所有规则都会自动被遵循：物体被直接投射到眼睛，并且在它们与眼睛前面的视图平面相遇的地方被绘制。
![](pic/Pasted%20image%2020240229210346.png)

## 4.3 计算视图射线

为了生成光线，我们首先需要光线的数学表示。光线实际上只是一个原点和传播方向；3D 参数化射线是最理想的：
$$p(t)=e+t(s-e)$$
![](pic/Pasted%20image%2020240229211752.png)
光线总是使用某种存储位置和方向的数据结构或对象在代码中表示。例如，在面向对象的程序中，我们可能会这样写：
![](pic/Pasted%20image%2020240229212053.png)
我们的所有光线生成方法都从称为相机坐标框的正交坐标系开始，我们将用 e 表示眼点或视点，u、v 和 w 表示三个基本矢量，通过 u 指向右侧(从相机的视角)，v 指向上方，和 w 向后指向，从而{u，v，w}形成右手坐标系。
最常见的构造相机坐标框的方法：
![](pic/Pasted%20image%2020240229212736.png)

### 4.3.1 正交视图

对于正交视图，所有光线都有同一个方向。即使正交视图本身没有视点，我们仍然可以使用相机坐标框的原点来定义光线开始的平面，这样物体就有可能在相机后面。
观察光线应该开始于由点 e 和矢量 u 和 v 定义的平面上；剩余下的是图像应该在平面上的哪里。我们将用四个数字来定义图像的尺寸，对于图像的四个边缘：L 和 r 是左右两个边的位置，从 e 点沿着 u 轴测量得来，b 和 t 是上下两个边的位置，从 e 点沿着 v 轴测量得来。通常$l\lt0\lt r \quad and \quad b\lt0 \lt t$。
![](pic/Pasted%20image%2020240229213450.png)
在第 3.2 节中，我们讨论了图像中的像素坐标。为了将具有 NxNy 个像素的图像拟合到一个大小为(r-L)x(t-b)的矩形中，这些像素在水平方向上间隔(r-L)/Nx，在垂直方向上间隔(t-b)/Ny，在边缘周围留出半像素空间，以便在图像矩形内居中像素格网。这意味着栅格图像中位置(i，j)像素的坐标是：
$$u = l+ \frac{r-l}{n_x}(i+0.5)$$
$$v = b+ \frac{t-b}{n_y}(j+0.5)$$
在正交视图中我们可以简单的用（u，v）作为射线的起点，毕竟我们已经知道射线的方向了。

创建一个斜视的正交视图同样简单：单独指定视角方向，而不是 copy -w。

### 4.3.2 透视视图

对于透视图，所有光线在视点具有相同的原点；而每个像素的方向不同。图像平面不再位于 e 处，而是位于 e 前面的某个距离 d 处；该距离是图像平面距离，通常称为焦距（因为它的作用与真实相机中焦距的作用相同）。每条光线的方向由视点和像素在图像平面上的位置定义：
$$ray.o = e$$
$$ray.d = -d\vec{w}+u\vec{u}+v\vec{v}$$
和正交视图的斜视一样，斜视透视视图可以通过指定图像平面的法向来实现。

## 4.4 射线与物体的交点

一旦我们生成了一条射线 e + td，接下来我们需要找到它与任意前方物体的第一个交点。基本射线相交是在 t0 = 0 和 t1 = +∞ 的情况下，在区间$[t_0,t_1]$上找到第一个交点。

### 4.4.1 射线与球面求交

给定射线$P(t)=e+td$和一个隐式曲面$f(p)=0$，当射线上的点满足方程时，交点便产生了。
$$f(p(t))=0\quad or \quad f(e+td) = 0$$
现在假设球面（中心 c，半径 R）的隐式方程为（向量式）：
$$(p-c)\cdot(p-c)-R^2 = 0$$
将射线方程带入：
$$(e+td-c)\cdot(e+td-c)-R^2 = 0$$
$$(d\cdot d)t^2+2d\cdot(e-c)t+(e-c)\cdot(e-c)-R^2=0$$
根据二次方程有解的条件（判别式$B^2-4AC\ge 0$）可以判断是否存在交点，如果存在那么交点为：
$$t=\frac{-d\cdot (e-c)\pm\sqrt{(d\cdot (e-c))^2-(d\cdot d)((e-c)\cdot(e-c)-R^2)}}{(d\cdot d)}$$
在实际应用中，要先确认判别式。另外交点上的单位法向量为$\frac{(p-c)}{R}$

### 4.4.2 射线与三角形求交

有诸多射线与三角形求交的算法。这里将介绍在参数化平面上使用中心坐标的方法，因为它不需要长期使用存储。
首先利用参数化曲面（3 点式三角面）和射线建立交点方程：
$$e+td=a+\beta (b-a)+\gamma (c-a)$$
$$0\le\alpha,\beta,\gamma\le1\quad and \quad \alpha+\beta+\gamma=1$$
一般来说都会和平面有交点，但是在不在三角形内还要看第二个条件。如果无解，要么三角形没有生成要么三角形面与射线平行。
可以将上式改造成线性方程组：
$$\begin{bmatrix} x_a-x_b&&x_a-x_c&&x_d\\y_a-y_b&&y_a-y_c&&y_d\\z_a-z_b&&z_a-z_c&&z_d \end{bmatrix}\begin{bmatrix} \beta \\ \gamma \\ t \end{bmatrix}=\begin{bmatrix} x_a-x_e\\y_a-y_e\\z_a-z_e \end{bmatrix}$$
最快求解 3 阶线性方程组的经典方法是克莱默法则：这里不细讲。它可以化简出一步完成的计算式。
![](pic/Pasted%20image%2020240301105208.png)
上式中有很多重复的结构，如$ei-hf$，我们可以重复使用这些数据来减少算数运算的次数。
最后是关于交点在三角形内的判定：
![](pic/Pasted%20image%2020240301110239.png)

### 4.4.3 软件中的射线求交

在光线追踪程序中，使用面向对象的设计是一个好主意，它有一个叫做 Surface 的类，带有派生类 Triangle, Sphere 等。射线可以相交的任何东西，包括一组表面或有效的数据结构都应该是 Surface 的子类。然后，光线追踪程序将对整个模型的表面有一个参考（引用？），并且可以轻易地添加新的对象类型和有效的数据结构。
Surface 类应当有一个关于求交的成员函数：

```cpp
class HitRecord
	Surface s
	real t
	Vec3 n

class Surface
	HitRecord hit(Ray r, real t0, real t1)
```

如果交点存在，那么交点距离 t 和表面法向 n 是必要的返回值，但一些其他数据像纹理坐标和表面切向可能也会被存储。
根据语言的不同，命中记录可能不是直接从函数返回，而是通过引用传递并填充（因为这是一个大型的数据结构，传递指针更快）。失误可以用 t=∞ 来表示。

### 4.4.4 射线与一组物体求交

当然，大多数有趣的场景由多个对象组成，当我们将光线与场景相交时，我们必须只找到沿着光线与相机最近的交叉点。
实现这一点的一个简单方法是将一组对象本身视为另一种类型的对象。要使射线与组相交，只需使射线与组中的对象相交并返回具有最小 t 值的交点。

```cpp
class Group:Surface{
	list-of-Surface surfaces
	HitRecord hit(Ray ray, real t0, real t1);
}

HitRecord hit(Ray ray, real t0, real t1){
	HitRecord closet-hit(inf) //initiate result with no-hit
	for s in surfaces do
		rec = s.hit(ray, t0, t1)
		if rec.t < inf then
			cloest-hit = rec
			t1 = t //continually reduce the range of intersection
	return cloest-hit
}
```

注意到`t1 = t`这句话可以不断地缩小求交的范围。所以新的击中目标一定是更近的。

一旦光线-场景求交可行，我们就可以渲染图像，但是更好的结果取决于包含更多的视觉线索。

## 4.5 着色 Shading

一旦一个像素的可见表面是已知的，像素值是通过评估一个着色模型来计算的。如何做到这一点完全取决于应用程序——从简单的启发式到复杂的基于物理的模型。完全相同的阴影模型可以用于光追或是光栅渲染。

### 4.5.1 光源

为了支持着色，光线追踪程序总是有一个光源列表。对于第 5 章的阴影模型（简单的），我们需要三种类型的光：

1. 点光，从空间中的一个点发出光，
2. 定向光，从单一方向照亮场景，
3. 环境光，提供恒定的照明来填补着色（这里相对于把 HDR 填成纯色来用，且不考虑物体间的遮挡）。

在功能更加丰富的系统中，支持其他类型的光，例如区域光(基本上是发光的场景几何体)或环境光(使用图像来表示来自遥远来源的光，这里说的是 HDR，像天空)。

计算由点光源或定向光源造成的着色需要一定的几何信息。我们需要一下四种向量：

1. 着色点的位置 x，可以使用射线和距离 t 计算得到。
2. 表面法线 n（取决于几何体，球体还是三角面），所有表面应当能够计算交点处的法线。
3. 光线方向 l，根据光源计算得到。
4. 视角方向 v，它是射线方向的反方向（$v=-d / \Vert d \Vert$）。

来自环境光源（纯色 HDR，且不考虑物体间的遮挡）的着色更简单：不存在光源向量 l，因为光来自四面八方。并且着色也不取决于视角 v，对于第五章的简单模型，它甚至不依赖于 x 或 n。

在包含多个灯光的场景中计算着色只是简单地将灯光的贡献加起来。在基本的光线追踪器中，您可以简单地循环所有光源，计算每个光源的着色，并将结果累积到像素中。

### 4.5.2 软件中的着色

光线追踪程序通常包含代表光源和材质的对象。光源可以是一个 Light 类的子类的实例，它们必须包含足够的信息来完全描述光源。由于着色也需要描述表面材料的参数，另一个有用的类是 material，它封装了评估着色模型所需的一切。

不同的系统采用不同的方法将光线和材质的计算分开。本章让光线负责所有的照明计算，而让材质负责计算 BSDF 值。：

```cpp
class Light{
	Color illuminate(Ray ray, HitRecord hrec)
}
class Material{
	Color evaluate(Vec3 l, Vec3 v, Vec3 n)
}
```

每个 surface 存储对自身材质的引用，故一个点光源类可以写成：

```cpp
class PointLight:Light{
	Color I;
	Vec3 p;
	Color illuminate(Ray ray, HitRecord hrec){
		Vec3 x = ray.evaluate(hrec.t)
		real r = ||p-x||
		Vec3 l = (p-x)/r
		Vec3 n = hrec.normal
		Color E = max(0, dot(n, l))I/r^2  //这里的r^2是光线衰减和距离平方呈反比
		Color k = hrec.surface.material.evaluate(l, v, n)
		return kE
	}
}
```

通过使环境系数成为材质的一个属性，这种也适用于将环境照明作为光源：

```cpp
class AmbientLight:Light{
	Color Ia;
	Color illuminate(Ray ray, HitRecord hrec){
		Color ka = hrec.surface.material.ka
		return ka*Ia
	}
}
```

光线着色的完整计算，包括求解交点和处理多个灯：

```cpp
void shade-ray(Ray ray, real t0, real t1){
	HitRecord rec = scene.hit(ray, t0, t1)
	if (rec.t < inf){
		Color c = 0
		for light in sence.lights{
			c += light.illuminate(ray, rec)
		}
		return c
	} else {
		return background-color
	}
}
```

这种设置将材质和灯光合理地分开，并允许您更透明地添加新类型的材质和灯光。纹理为光线跟踪器的体系结构增加了一些复杂性。着色本身使 3D 对象的图像更逼真和易于理解，但它不显示它们与其他对象的交互。

### 4.5.3 阴影

一旦你的光线跟踪器有了基本的着色，就可以很容易地添加点和方向光的阴影。
想象自己在表面上的点 x，如果我们朝光源看，看到我们和光源之间有一个物体，那么这个点应当处在阴影中。如果在我们和光源之间没有物体，那么光不会被阻挡（无阴影）。
![](pic/Pasted%20image%2020240301194734.png)
光线 x+tl 不会击中任何物体，因此点 x 不在阴影中。另一方面，点 x‘处于阴影中是因为射线 x’+tl‘确实击中了对象（画反了）。那些决定进入或从阴影中出来的射线，叫做阴影射线，以此来和视图射线作区分。

为了获得阴影算法，我们在代码中添加了一个 if 语句，该语句添加了来自光源的阴影，以首先确定光线是否被阴影。在一种简单的实现中，阴影射线将检查$t\in[0,\, r]$，但由于数值不精确，这可能导致与其上的表面相交（在射线的最开始就相交）。相反我们会测试$t\in[0+\epsilon,\, r]$

```cpp
HitRecord srec = sence.hit(Ray(x, l), 0, r)
if srec.t < inf then
	point in shadow
else
	point in light
```

定向光源的阴影测试类似，但使用 t1=oo 而不是 r。请注意，每个灯光的照明计算需要单独的阴影光线，**并且在计算环境光阴影时没有阴影测试**。阴影在显示附近对象之间的关系方面发挥着重要的视觉作用。

### 4.5.4 镜面反射

在光线跟踪程序中添加理想的镜面反射是很简单的。
![](pic/Pasted%20image%2020240301200512.png)
从 e 方向向表面上看去，可以看到 r 方向上的物体。矢量 r 是矢量 d 在表面法线 n 上的反射，可以使用 d 在表面法线方向上的投影来计算
$$r = d-2(d\cdot n)n$$
在现实世界中，当光从表面反射时，一些能量损失，这种损失对于不同的颜色可能是不同的。例如，黄金反射黄色比蓝色反射得更多，这可以通过在 shade-ray 中添加一个递归调用来实现，该调用在考虑了所有灯光之后再添加一个贡献
`color c += km*shade-ray(Ray(p, r), 0, inf)`
其中 Km 是镜面反射的 RGB 颜色。我们需要确保传递到 t0=e，原因与我们处理阴影光线的原因相同；我们不希望反射光线击中产生反射光线的对象。

上面递归调用的问题是它可能永远不会终止。这可以通过添加最大递归深度来修复。只有在 Km 不为零的情况下才能生成反射光线，代码将更有效。

使用恒定的镜面反射系数 Km 具有简单光线跟踪器的特殊外观特征(图 4.17)；在现实世界中，该系数根据入射角度的不同而变化很大。
