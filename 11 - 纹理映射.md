# 11 - 纹理映射

当试图复制真实世界的外观时，人们很快意识到几乎没有任何表面是无特征的。木材与谷物一起生长;皮肤长皱纹;布料呈现其编织结构;油漆上还会有刷或滚筒留下的痕迹。即使是光滑的塑料也有凹凸不平的地方，光滑的金属也有加工过程的痕迹。曾经毫无特色的材料很快就会布满痕迹、凹痕、污渍、划痕、指纹和污垢。

在计算机图形学中，我们把所有这些现象统称为“空间变化表面属性”——表面的属性在不同的地方变化，但不会以有意义的方式真正改变表面的形状。为了实现这些效果，所有的建模和渲染系统都提供了一些纹理映射的方法：使用一个图像，称为纹理映射，纹理图像，或者仅用纹理来称呼它们，来存储你想要在表面上的细节，然后用数学方法将图像“映射”到表面上。

事实证明，一旦将图像映射到表面的机制存在，就会有许多不太明显的方法可以使用，这些方法可以实现的效果远超我们引入表面细节的基本目的。纹理可以用来制作阴影和反射，提供照明，甚至定义表面形状。在复杂的交互程序中，纹理用于存储与图片无关的各种数据!

虽然基本思想很简单，但几个实际问题使纹理的使用变得复杂。首先，纹理很容易被扭曲，设计将纹理映射到表面的功能是具有挑战性的。此外，纹理映射是一个重采样过程，就像重新缩放图像一样，正如我们在第 10 章看到的，重采样可以很容易地引入混叠伪影。纹理映射和动画一起使用很容易产生真正戏剧性的混叠，并且纹理映射系统的许多复杂性是由这些抗混叠措施带来的。

## 11.1 查找纹理值

首先，让我们考虑一个简单的纹理映射应用程序。我们有一个场景与木地板，我们希望地板的漫射颜色是由一个图像显示木地板与木纹控制。无论我们是使用光线追踪还是光栅化，计算光线表面交叉点或光栅器生成的片元的颜色的着色代码需要知道着色点的纹理颜色，以便在 Lambertian 着色模型中使用它作为漫射颜色。

为了获得这种颜色，着色器执行纹理查找：它在纹理图像的坐标系统中找出与着色点对应的位置，并在图像中读取该点的颜色，从而得到纹理样本。这种颜色随后用于着色，由于纹理查找发生在每个看到地板的像素的纹理中的不同位置，因此图像中显示出不同颜色的图案。

这将我们带到了纹理映射的第一个关键要素：我们需要一个从表面映射到纹理的函数，这样我们才可以很容易地计算每个像素。它就是纹理坐标函数。它声明了表面上所有点的纹理坐标。从数学上讲，它是表面 S 到纹理域 T 的映射。
![](pic/Pasted%20image%2020240318200554.png)
集合 T 通常称为纹理空间，通常只是包含图像的一个矩形；通常使用单位正方形(u，v)。一幅图像只有一个观察投影，而场景中的每个对象都可能具有完全独立的纹理坐标函数。
![](pic/Pasted%20image%2020240318203316.png)
另一个问题：从非常倾斜的角度渲染高对比度纹理到低分辨率图像，会产生混叠伪影。图 11.3 显示了一个更大的平面，使用了相同的方法，但使用了高对比度的网格图案和朝向地平线的视图。

我们现在已经看到了基本纹理映射的两个主要问题：

1. 定义纹理坐标函数
2. 在不引入太多混叠的情况下查找纹理值。

## 11.2 纹理坐标函数

设计好纹理坐标函数 φ 是获得良好纹理映射效果的关键要求。
你可以把它想象成决定如何变形一个平面的矩形图像，使它符合你想要绘制的 3D 表面。或者，你也可以把表面轻轻压平，不让它起皱、撕裂或折叠，这样它就能平躺在图像上。
有时，这很简单:也许 3D 表面已经是一个平坦的矩形!在其他情况下，这是非常棘手的:3D 形状可能非常复杂，比如角色身体的表面。

定义纹理坐标函数的问题对计算机图形学来说并不新鲜。确切地说，制图师在设计覆盖地球表面大片区域的地图时也面临着同样的问题：从弯曲的地球仪到平面地图的映射不可避免地会导致区域、角度和/或距离的扭曲，这很容易使地图变得非常具有误导性。几个世纪以来，人们提出了许多地图投影，所有这些投影都是为了平衡纹理映射所面临的同样的竞争问题——在覆盖大片连续区域的同时，尽量减少各种失真。

你可以用任何你能想到的方式来定义 φ。但有几个相互竞争的目标需要考虑:

1. 双射性。在大多数情况下，您希望 φ 是双射的，以便表面上的每个点映射到纹理空间中的不同点。如果几个点映射到相同的纹理空间点，则纹理中一个点的值将影响表面上的几个点。如果您希望纹理在表面上重复(想想具有重复图案的墙纸或地毯)，那么故意引入从表面点到纹理点的多对一映射是有意义的，但您不希望这种情况偶然发生。
2. 尺寸失真。纹理的尺度应该在整个表面上近似恒定。也就是说，表面上任何距离相同的近距离点都应该映射到纹理中距离相同的点。对于函数 φ， φ 的导数的大小不应该变化太大。
3. 形状扭曲。纹理不应该很扭曲。也就是说，在表面上绘制的一个小圆圈应该映射到纹理空间中一个合理的圆形形状，而不是一个非常压扁或拉长的形状。对于 φ， φ 的导数在不同方向上不应该相差太大。
4. 连续性。不应该有太多的接缝：表面上的相邻点应该映射到纹理中的相邻点。也就是说，φ 应该是连续的，或者有尽可能少的不连续点。在大多数情况下，一些不连续性是不可避免的，我们希望将它们放在不显眼的位置。

由参数方程定义的曲面有一个内置的纹理坐标函数选择：简单地反转定义曲面的函数，并使用曲面的两个参数作为纹理坐标。这些纹理坐标可能有也可能没有理想的属性，这取决于表面，但它们确实提供了映射。

但是对于隐式定义的曲面，或者只是由三角形网格定义的曲面，我们需要一些其他的方法来定义纹理坐标，而不依赖于现有的参数化。一般来说，定义纹理坐标的两种方法是

1. 从表面点的空间坐标几何地计算纹理坐标
2. 对于网格表面，将纹理坐标的值存储在顶点并在表面上插值。

### 11.2.1 由几何确定的纹理坐标

几何确定的纹理坐标用于简单形状或特殊情况，作为快速解决方案，或作为设计手动调整纹理坐标映射的起点。

#### 平面投影

![](pic/Pasted%20image%2020240318210333.png)
也许，从 3D 到 2D 最简单的映射是平行投影——与用于正交投影的映射相同。正如正交投影归结为乘以矩阵并丢弃 z 分量一样，通过平面投影生成纹理坐标可以通过简单的矩阵乘法来完成:
$$\phi(x,y,z)=(uv)\quad where\quad \begin{bmatrix} u\\v\\ \star \\1 \end{bmatrix}=M_t\cdot\begin{bmatrix} x\\y\\z\\1 \end{bmatrix}$$
其中纹理矩阵 Mt 表示一个仿射变换，星号表示我们不关心第三个坐标的结果。

这对于大多数平坦的表面来说非常有效，表面法线没有太多变化，并且可以通过取平均法线找到一个好的投影方向。然而，对于任何一种封闭形状，平面投影都不会是双射的：前面和后面的点将映射到纹理空间中的同一点。
![](pic/Pasted%20image%2020240318211136.png)
通过简单地将透视投影替换为正交投影，我们得到投影纹理坐标：
$$\phi(x,y,z)=(u / w,v / w)\quad where\quad \begin{bmatrix} u\\v\\ \star \\w \end{bmatrix}=P_t\cdot\begin{bmatrix} x\\y\\z\\1 \end{bmatrix}$$

#### 球坐标

对于球面，经纬度参数化是一种常用的方法。它在两极附近有很多失真，这可能会导致一些问题，但它确实覆盖了整个球体，只有沿着一条纬度线的 uv 断裂。

形状大致为球形的表面可以使用纹理坐标函数参数化，该函数使用径向投影将表面上的点映射到球体上的点：从球体中心穿过表面上的点取一条线，并找到与球体的交点。这个交点的球坐标是你在表面上开始的点的纹理坐标。

另一种说法是，你用球坐标(ρ， θ， φ)表示曲面点，然后放弃 ρ 坐标（球半径），将 θ 和 φ 分别映射到[0,1]范围。见公式：
$$\phi(x,y,z)=\big( [\pi+atan2(y,x)] / 2\pi,[\pi-acos(z / \Vert x\Vert) / \pi] \big)$$
![](pic/Pasted%20image%2020240319110246.png)
如果从中心点可以看到整个表面，那么球坐标映射将在除极点以外的任何地方都是双射的。它在两极附近继承了与经纬度图相同的扭曲。

#### 柱坐标

对于柱状而非球形的对象，从轴向外投射到圆柱体上可能比从点投射到球体上效果更好。与球面投影类似，这相当于转换为柱坐标并放弃半径:
$$\phi(x,y,z)=\big( [\pi+atan2(y,x)] / 2\pi, 1/ 2[1+z] \big)$$

#### 立方体贴图 CubeMaps

使用球坐标参数化球形或球状形状会导致两极附近的形状和面积高度失真，这通常会导致可见的伪影，说明纹理有两个特殊的点会出现问题。
一种流行的替代方案是更加统一，但代价是有更多的不连续。这个想法是投射到一个立方体上，而不是一个球体上，然后对立方体的六个面使用六个独立的正方形纹理。六个正方形纹理的集合称为立方体贴图。
这在立方体的所有边缘上引入了不连续性，但它使形状和面积的畸变保持在低水平。

计算立方体贴图纹理坐标也比计算球坐标便宜，因为投影到平面上只需要一个除法——本质上与观看的透视投影相同。例如，对于一个点投射到立方体的+z 面：
$$(x,y,z)\to \left( \frac{x}{z},\, \frac{y}{z} \right)$$
令人困惑的问题是如何建立在六个面上 uv 方向的约定。任何约定都可以，但是选择的约定会影响纹理的内容，因此标准化很重要。
由于立方体贴图常常用于那些从内部向外看去的几何体，因此常用的约定是从内部向外看时，v 轴能顺时针旋转至 u 轴。
![](pic/Pasted%20image%2020240319111819.png)
通常，立方体贴图被打包在一个单独的图像中存储，安排得就像立方体被展开一样。
![](pic/Pasted%20image%2020240319111103.png)

### 11.2.2 插值的纹理坐标

对于需要更加精细化控制纹理坐标的场合，例如三角形网格表面，你可以显式的存储纹理坐标在每一个顶点上，并且利用重心坐标来插值它们。它的工作方式与你在网格上定义的任何其他平滑变化量完全相同：颜色，法线，甚至 3D 位置本身。
![](pic/Pasted%20image%2020240319112257.png)
让我们看一个三角形的例子。通过查看呈现的三角形上出现的图案，您可以推断出三个顶点的纹理坐标是(0.2,0.2)、(0.8,0.2)和(0.2,0.8)，因为它们是纹理中出现在三角形三个角上的点。
就像上一节中几何确定的映射一样，我们通过给出从表面到纹理域的映射来控制纹理在表面上的位置，在这种情况下，通过指定每个顶点在纹理空间中的位置来控制纹理。一旦你定位了顶点，在三角形上的线性插值会处理剩下的部分。
![](pic/Pasted%20image%2020240319112447.png)
由顶点纹理坐标定义的纹理映射的质量取决于分配给顶点的坐标——即网格在纹理空间中的布局方式。无论分配什么坐标，只要网格中的三角形共享顶点（邻接），它们的坐标映射就是连续的，因为相邻的三角形将在它们共享的边上就达成纹理坐标的一致。但是前面所说的我们期待的其他特性并非自动实现的。双射性意味着三角形在纹理空间中不重叠——如果它们重叠，则意味着纹理中的某个点将出现在表面上的多个地方。
![](pic/Pasted%20image%2020240319113106.png)
当纹理空间中的三角形面积与它们在 3D 中的面积成比例时，尺寸失真较小。例如，一个人的鼻子通常被压缩到纹理空间中一个相对较小的区域。尽管鼻子上的三角形比脸颊上的小，但纹理空间中的这个尺寸的比例将更加极端（更小）。结果是鼻子上的纹理被放大，因为一个小区域的纹理必须覆盖大面积的表面。类似地，比较前额和太阳穴，三角形在 3D 中的大小是相似的，但是太阳穴周围的三角形在纹理空间中较大，导致纹理在太阳穴那里显得较小。

类似地，当三角形的形状在 3D 和纹理空间中相似时，形状失真也很低。

### 11.2.3 平铺、环绕模式 与 纹理变换

允许纹理坐标超出纹理图像的边界通常是有用的。有时，纹理坐标计算中的舍入误差可能会导致正好位于纹理边界上的顶点轻微地向外移动，纹理映射机制不应该因此而失效。

如果纹理只覆盖表面的一部分，但纹理坐标已经设置成整个表面，一种选择是准备一个纹理图像，大部分是空白的，内容在一个小区域。但这可能需要一个非常高分辨率的纹理图像，另一种选择是放大所有纹理坐标，它们可以覆盖更大的范围，例如[- 4.5,5.5]×[- 4.5, 5.5]，以便将单位正方形放置在表面中心十分之一的位置。

> （被纹理覆盖的地方正常地使用 0 到 1 的 uv 值）

对于这种情况，纹理图像覆盖的单位正方形区域之外的纹理查找应该返回一个恒定的背景色。一种方法是设置背景色，以便在单位方块外的纹理查找时返回。如果纹理图像已经具有恒定的背景颜色(例如，白色背景上的徽标)，则在平面上自动扩展此背景的另一种方法是安排在单位正方形外的查找，以返回边缘上最近点的纹理图像的颜色，通过将 u 和 v 坐标固定到图像中从第一个像素到最后一个像素的范围来实现。

有时，我们想要一个重复的图案，如棋盘、瓷砖地板或砖墙。如果花纹在矩形网格上重复，那么创建具有相同数据的许多副本的图像将是浪费的。相反，我们可以使用环绕索引来处理纹理图像之外的纹理查找——当查找点退出纹理图像的右边缘时，它会绕到左边缘。使用像素坐标上的整数余数操作可以非常简单地处理这个问题。

有了环绕模式，我们可以自由地把纹理想象成一个函数，它返回无限二维平面上任何一点的颜色。当我们使用图像指定纹理时，这些模式描述了如何使用有限的图像数据来定义该函数。在 11.5 节中，我们将看到程序纹理可以自然地扩展到无限平面，因为它们不受有限图像数据的限制。由于两者在逻辑上都是无限的，所以这两种类型的纹理是可以互换的。

当调整纹理的比例和位置时，为了避免真正改变生成纹理坐标的函数或是存储在顶点中的纹理坐标，我们使用一个变换矩阵，这个矩阵在我们取出 uv 后对 uv 做变换。
$$\phi(x)=M_T\cdot \phi_{model}(x)$$

### 11.2.4 连续性与接缝

虽然低失真和连续性是纹理坐标函数的良好属性，但不连续性通常是不可避免的。对于任何闭合的 3D 曲面，没有连续的双射函数将整个曲面映射到纹理图像是拓扑学的常识。必须要提到的是，通过在纹理坐标发生变化的曲面上引入接缝——我们可以在其他任何地方都具有低失真。
上面讨论的许多几何确定的映射已经包含接缝：在球面和柱面坐标中，接缝是由 atan2 计算的角度从 pi 到-pi 而在立方体地图中，接缝沿着立方体边缘其中贴图在六个正方形纹理之间切换。

使用插值纹理坐标，接缝需要特别考虑，因为它们不是自然发生的。
我们之前观察到，插值的纹理坐标在共享顶点网格（邻接的三角面）上是自动连续的——纹理坐标的共享保证了这一点。但这意味着，如果一个三角形横跨接缝，其中一些顶点在一边，一些顶点在另一边。虽然插值机制将提供连续的映射，但是它很可能会高度扭曲或折叠，所以它不是双射的。

例如，在地球底部附近有一个三角形，它的一个顶点在新西兰南岛的顶端，在北岛东北约 400 公里处的太平洋上的另一个顶点。在这两个点之间飞行的明智的飞行员会飞越新西兰，但航线开始于东经 167（+167），结束于西经 179（即，经度—179），所以线性插值选择一条在途中穿过南美洲的路线。这导致整个地图的向后复制被压缩成穿过 180 度子午线的三角形条！解决方案是用等效经度 181E 来标记第二个顶点，但这只会把问题推到下一个三角形上。（地理不好，看不懂）
![](pic/Pasted%20image%2020240319144646.png)

创建清晰过渡的唯一方法是避免在接缝处共享纹理坐标（接缝上的顶点对应多个纹理坐标）。为了做到这一点，我们复制接缝处的顶点：对于每个顶点，我们添加一个具有相同经度的顶点，相差 360，接缝相对两侧的三角形使用不同的顶点。

### 11.2.5 渲染系统中的纹理坐标

纹理用于各种渲染系统，虽然基本原理是相同的，但光线追踪和光栅化系统的细节是不同的。
纹理坐标是正在渲染的模型的一部分，场景描述需要包含足够的信息来定义它们是什么。大多数情况下，这意味着将纹理坐标存储为所有三角形网格的每个顶点属性。如果渲染系统直接支持除网格以外的几何图元，这些图元通常具有预定义的纹理坐标，可能为每种图元类型选择映射方案。

在光线追踪渲染器中，支持光线相交的表面不仅要能够计算交叉点和表面法线，还要能够计算交叉点的纹理坐标。像其他关于交点的信息一样，纹理坐标可以存储在命中记录中。对于三角形网格表示的几何图形，射线与三角形求交代码将通过重心插值从存储在顶点上的纹理坐标计算纹理坐标，而对于其他类型的几何图形，求交代码必须直接计算纹理坐标。

在基于栅格化的系统中，三角形通常是唯一支持的几何类型，因此所有表面都必须转换为这种形式。纹理坐标可以在模型中读取(通常情况下)，或者对于在代码中生成的三角形网格，它们可以在创建网格时计算和存储纹理坐标。另外，对于可以从其他顶点数据计算的纹理坐标(例如，从 3D 位置计算纹理坐标)，纹理坐标也可以在顶点着色器中计算并传递给光栅器。纹理坐标然后由光栅器插值，这样每个片段着色器的调用都有适合其片段的纹理坐标。

## 11.3 抗锯齿纹理查找

纹理映射的第二个基本问题是抗锯齿。渲染纹理映射图像是一个采样过程:将纹理映射到表面上，然后将表面投影到图像上，在图像平面上产生一个 2D 函数，我们以像素为单位对其进行采样。正如我们在第 10 章看到的那样，当图像包含细节或尖锐边缘时，使用点样本会产生混叠伪影，并且由于纹理的全部目的是引入细节，它们成为像我们在图 11.3 中看到的那样混叠问题的主要来源。

正如线条或三角形的抗锯齿光栅化(第 9.3 节)、抗锯齿光线跟踪或下采样图像(第 10.4 节)一样，解决方案是让像素在一个面积上采样而非在一个点上采样，这个面积等同于像素的大小。
使用与抗锯齿光栅化和光线追踪相同的超采样方法，只要有足够的样本，就可以在不改变纹理映射机制的情况下获得出色的结果：在一个像素区域内的许多样本将落在纹理映射的不同位置，并且使用不同纹理查找计算的着色结果平均是一种精确的方法来近似图像在像素上的平均颜色。

> 从光追的角度想：从一个像素的方形窗口中发射 500 射线击中表面的不同位置，我们在这些位置上都计算 uv，都采样纹理，最后像素的最终颜色是 500 次纹理查找的平均颜色。

然而，对于细节纹理，它需要非常多的样本才能得到好的结果，这是缓慢的。在表面纹理存在的情况下，有效地计算该区域平均值是纹理抗混叠的第一个关键问题。

纹理图像通常由光栅图像定义，因此也需要考虑重建问题，就像上采样图像一样(第 10.4 节)。对于纹理的解决方案是相同的：使用重建过滤器在纹理之间进行插值。

### 11.3.1 一个像素的足迹

使抗锯齿纹理比其他类型的抗锯齿纹理更复杂的是，渲染图像和纹理之间的关系是不断变化的。每个像素值都应该用图像中属于像素的区域上的平均颜色来计算，并且在像素查看单个表面的常见情况下，这对应于对表面上的一个区域进行平均。如果表面颜色来自纹理，这反过来相当于对纹理的相应部分进行平均，称为像素的纹理空间足迹（一个像素的贡献来自纹理上的哪些区域）。图 11.16 说明了正方形区域(可能是低分辨率图像中的像素区域)的足迹如何映射到地板纹理空间中大小和形状非常不同的区域。
![](pic/Pasted%20image%2020240319152645.png)

> 上图中，距离摄像机遥远的点，可能在纹理空间上占据更多的面积

回想一下纹理渲染中涉及到的三个空间：将 3D 点映射到图像中的投影变换 π 和将 3D 点映射到纹理空间中的纹理坐标函数 φ。为了处理像素足迹，我们需要了解这两个映射的组合：首先向后利用 π 从图像映射到表面，然后使用 φ 映射到纹理空间。这个组合 ψ = φ◦π−1 决定了像素的足迹：像素的足迹是该像素在映射 ψ 下的纹理的正方形区域的图像。

纹理抗锯齿的核心问题是计算像素在纹理空间上覆盖区域的平均值。一般来说，要做到这一点可能是一项非常复杂的工作：对于一个具有复杂表面形状的遥远物体，轮廓线可能是一个复杂的形状，覆盖了纹理空间中的大片区域，也可能是几个不相连的区域。但在典型情况下，一个像素位于表面的平滑区域，该区域被映射到纹理中的单个区域。

由于既包含图像到表面的映射，也包含从表面到纹理的映射，因此足迹的大小和形状取决于视角情况和纹理坐标函数。当曲面靠近相机时，像素足迹将会较小；当表面移动得越远，足迹就越大。当以斜角查看表面时，表面上像素的足迹被拉长，这通常意味着在纹理空间中也会被拉长。即使对于固定的视图，纹理记录函数也会导致足迹中的变化：如果它扭曲面积，则足迹的大小将变化，如果它扭曲形状，则它们甚至可以被拉长。

然而，为了找到计算抗锯齿查找的高效算法，需要一些实质性的近似。当函数平滑时，通常使用线性近似。在纹理抗锯齿的情况下，这意味着将从图像空间到纹理空间的映射近似为从 2D 到 2D 的线性映射（J 是映射函数导数的近似值）：
$$\psi(x)=\psi(x_0)+J(x-x_0)$$
如果（x，y）是图像空间的坐标，而（u，v）是纹理空间的坐标，那么：
$$J=\begin{bmatrix} \frac{du}{dx}& \frac{du}{dy}\\ \frac{du}{dx} & \frac{dv}{dy} \end{bmatrix}$$
其中四个导数描述了当我们改变 x 和 y 时，图像中在点（x，y）处看到的纹理点（u，v）如何变化。
![](pic/Pasted%20image%2020240319155130.png)
几何解释是：图像中以 x 为中心的单位正方形像素区域，将近似映射到纹理空间中以$\psi(x)$为中心的一个平行四边形，其边界平行与向量 ux =（du/dr，dv/dx）和 uy =（du/dy，dv/dy）平行。

导数矩阵 J 是有用的，因为它给出了变量在纹理空间上的变化范围。幅度较大的导数表示较大的纹理空间足迹，导数矢量 ux 和 uy 之间的关系表示形状。当它们正交且长度相同时，足迹为正方形，当它们倾斜和/或长度差别很大时，足迹就会变长。

我们现在已经达到了通常被认为是“正确答案”的问题的形式：在特定图像空间位置处的过滤纹理采样应该是由该点处导数定义的平行四边形足迹上的平均值。这个结论中已经加入了一些假设：图像到纹理的映射是平滑的——但它已经足够精确，已经可以获得出色的图像质量。
然而，这个平行四边形面积平均值太昂贵，无法准确计算，因此使用了各种近似。纹理抗锯齿的方法在近似此查找时所做的速度/质量权衡方面有所不同。

### 11.3.2 重建

当纹理足迹小于纹理元时，我们会放大纹理，将它映射到图像中。这种情况类似于图像上采样，主要考虑的是在纹理元之间进行插值，以产生一个平滑的图像，在这种情况下纹理元的网格不明显。正如图像上采样一样，这个平滑过程是由重建滤波器定义的，该重建滤波器用于计算纹理空间中任意位置的纹理样本。
![](pic/Pasted%20image%2020240319160259.png)
考虑因素与图像重构几乎相同，但有一个重要的区别。在图像重构中，任务是在规则网格上计算输出样本，而规则性使得在可分离重构滤波器的情况下进行了重要的优化。在纹理滤波中，查找图案不规则，样本必须单独计算。这意味着大的高质量重构滤波器使用起来非常昂贵，通常用于纹理的最高质量过滤器是双线性插值。

> 重建纹理时，用周围像素的双线性插值计算目标点的颜色值。

双线性插值纹理样本的计算与双线性插值上采样图像中的一个像素计算相同。首先，我们将纹理空间样本点用(实值)体素坐标表示，然后我们读取四个相邻体素的值并对它们进行平均。
![](pic/Pasted%20image%2020240319161900.png)
在许多系统中，这一操作成为一个重要的性能瓶颈，主要是因为从纹理数据中获取四个纹理值所涉及的内存延迟。纹理样本点的读取顺序是不规则的，因为从图像到纹理空间的映射是任意的。但通常是一致的，因为附近的图像点倾向于映射到附近的纹理点，这些纹理点可能读取相同的纹理元。出于这个原因，高性能系统有专门用于纹理采样的硬件，用于处理插值和管理最近使用的纹理数据的缓存，以最大限度地减少从存储纹理数据的内存中获取缓慢数据的数量。

在阅读了第 10 章之后，你可能会抱怨，对于一些要求苛刻的应用，线性插值可能不是一个足够平滑的重建。然而，通过使用更好的过滤器将纹理重新采样到更高的分辨率，它总是可以做得足够好，这样纹理就足够光滑，双线性插值就可以很好地工作。

> 线性插值的效果本身不好，但是可以使用优秀的滤波器将纹理重采样到更高的分辨率
> 这样一来，即便垃圾如双线性插值的重构滤波，也能在足够光滑的纹理上采样出优秀的效果

### 11.3.3 MipMapping

只有在纹理被放大的情况下，良好的插值器才有用：在这种情况下，像素的覆盖区域比纹理元的间距还小。
只有当一个像素足迹覆盖了许多纹理元时，才可以安全的采样以获得抗锯齿效果，通过计算多个纹理元的均值。

> [!note] Texel 纹理元
> ![](https://img-blog.csdn.net/20170315165913210)

一种非常准确的方法是找到足迹中的所有纹理元并将它们相加。然而，当占用空间很大时，这可能会非常昂贵——仅仅一次查找就可能需要读取数千个纹理元。更好的方法是预先计算和存储纹理在不同大小和位置的各个区域上的平均值。

这个想法的一个非常流行的版本被称为“MIP 映射”。mipmap 是一组纹理序列，它们都包含相同的图像，但分辨率越来越低。原始的全分辨率纹理图像被称为 mipmap 的基本级别或级别 0，而级别 1 是原图 2 倍降采样而生成的，从而得到具有四分之一纹理元的图像。
粗略地说，该图像中的纹理是 0 级图像中 2 × 2 纹理大小的正方形区域的平均值。

这个过程可以根据需要继续定义尽可能多的 mipmap 级别：通过将 k−1 级别的图像降采样来计算 k 级别的图像。例如，从 1024 × 1024 的纹理图像开始，我们可以生成具有 11 个级别的 mipmap:级别 0 是 1024 × 1024；级别 1 是 512 × 512，以此类推，直到级别 10，即只有一个纹理元。这种以一系列越来越低的采样率表示相同内容的图像的结构被称为图像金字塔。

### 11.3.4 带有 Mipmaps 的基本纹理过滤器

有了 mipmap 或图像金字塔，纹理过滤可以比单独访问许多纹理更有效地完成。
当我们需要在大面积上平均纹理值时，我们只需使用来自更高级别的 mipmap 的值。最简单、最快的方法是在 mipmap 中选择级别，使该级别上的纹理元的大小与像素占用的大小大致相同。当然，像素足迹在形状上可能与由 texel 表示的(总是正方形的)区域完全不同，我们可以预期这会产生一些伪影。

暂且不考虑当像素足迹具有拉长形状时该怎么办的问题，假设足迹是一个宽度为 D 的正方形，以全分辨率纹理（level_0）中的 texel 来衡量。什么级别的 mipmap 适合采样？由于 k 层的纹理覆盖了宽度为 2k 的正方形，因此选择 k 似乎是合适的：
$$2^k\approx D\quad and \quad k=\log_2{D}$$
当然，这在大多数情况下会给出 k 的非整数值，而我们只存储了整数级别的 mipmap 图像。两种可能的解决方案是：

1. 只查找最接近 k 的整数的值(效率高，但在 level 之间的突然转换时产生接缝)，
2. 查找最接近 k 的两个整数的值，并对值进行线性插值(工作量增加一倍，但更平滑)。

在我们真正写下对 mipmap 进行采样的算法之前，我们必须决定当足迹不是正方形时，我们将如何选择“宽度”D。一些可能的方法是使用面积的平方根或找到足迹的最长轴并将其称为宽度。一个很容易计算的折衷方法是使用最长边的长度：
$$D=max\{ \Vert u_x \Vert,\Vert u_y \Vert \}$$
![](pic/Pasted%20image%2020240319165612.png)
基本的 mipmapping 在消除混叠方面做得很好，但它无法处理拉长或各向异性的像素足迹，所以当以掠掠角度观察表面时，它的表现并不好。
远处地板上的点以非常陡峭的角度观察，导致非常各向异性的足迹，mipmapping 近似于更大的正方形区域。生成的图像在水平方向上会显得模糊。

### 11.3.5 各向异性过滤器

mipmap 可以与多个查找一起使用，以更好地近似延长的占用空间。这个想法是基于最小的轴来选择 mipmap 级别而非最长轴，然后将长轴上多个级别的采样求均值。
![](pic/Pasted%20image%2020240319165820.png)

## 11.4 纹理映射的应用

一旦你理解了为表面定义纹理坐标的想法以及查找纹理值得机制，这些知识由很多用处。然而，纹理是一种十分常见的工具，它仅仅受限于编程者的想象力。

### 11.4.1 控制着色参数

纹理映射最基本的用途是允许着色计算中使用的漫反射颜色——无论是在光线跟踪器中还是在片段着色器中——仅仅取决于从纹理查找的值来引入颜色变化。纹理漫反射组件可用于粘贴贴花、油漆装饰或在表面上打印文本，它还可以模拟材料颜色的变化，例如木材和石头。

然而，没有任何限制我们只能改变漫反射颜色。任何其他参数，如镜面反射或镜面粗糙度，也可以是纹理的。例如，在许多情况下，不同参数的贴图是相互关联的。例如，一个印有徽标的光滑白色陶瓷杯可能会比较粗糙。一本用金属油墨印刷的书名可能会同时改变漫反射色、高光色和粗糙度。

### 11.4.2 法线贴图与凹凸贴图

另一个对着色很重要的量是表面法线。有了插值法线，我们才知道着色法线不必与表面的几何法线相同。法线贴图利用了这一点，使着色法线依赖于从纹理贴图中读取的值。最简单的方法是将法线存储在纹理中，在每个纹理中存储三个数字，而不是作为颜色的三个组成部分，作为法向量的 3D 坐标。

但是，在使用法线映射之前，我们需要知道从映射中读取的法线是用什么坐标系表示的。将法线直接存储在物体空间中，在用于表示几何本身的相同坐标系中，这是最简单的：从纹理中读出的法线可以与表面本身的法线以完全相同的方式使用：在大多数情况下，它将需要转换到世界空间中进行照明计算，就像几何中的法线一样。

然而，存储在对象空间中的法线映射本质上是与表面几何相关联的，为了用几何法线重现结果，法线映射的内容必须跟踪表面的方向。此外，如果表面要变形，使几何法线发生变化，则对象空间法线映射不能再使用，因为它会继续提供相同的法线。

> （真正的法线是几何体表面法线与纹理法线的叠加）

解决方案是为附着在表面上的法线定义一个坐标系。这样的坐标系可以基于曲面的切空间来定义：选择一对切向量，用它们来定义一个标准正交基。纹理坐标函数本身提供了一种选择一对切向量的有用方法：使用与常量 u 和 v 直线相切的方向。这些切线通常不是正交的，但我们可以使用数学方法来标准正交化，或者可以使用表面法线和一个切向量来定义。

当法线以此基表示时，它们的变化要小得多;由于它们大多指向光滑表面的法线方向附近，因此它们将靠近法线映射中的向量(0,0,1)T。

法线贴图从何而来？通常它们是从一个更富细节的几何体中计算出来的，所得的光滑表面只是原几何体的一个近似值：其他时候，它们可以直接从真实的表面测量。它们也可以作为建模过程的一部分进行编写。在这种情况下，使用凹凸贴图来间接指定法线通常是很好的。我们的想法是，凹凸贴图是一个高度场：一个函数，它给出了光滑表面之上的细节表面的局部高度。在数值高的地方，表面突出在光滑的表面之外；在数值较低的地方，地表在它下面后退。例如，凹凸贴图中的一条狭窄的暗线是划痕，或者一个小白点是凹凸。

从凹凸贴图中导出法线贴图很简单:法线贴图(在切线帧中表示)是凹凸贴图的导数。
![](pic/Pasted%20image%2020240319173643.png)
图 11.21 显示了纹理贴图用于创建木纹颜色和模拟增加的表面粗糙度，因为完成浸泡到更多的多孔部分的木材，与凹凸贴图一起创建一个不完美的完成和板之间的间隙，使一个逼真的木地板。

### 11.4.3 置换贴图（位移贴图）

法线贴图的一个问题是，它们实际上根本不会改变表面；它们只是一个着色诡计。在静态图像中，尽管几何体显示出凹凸的外观，但是它的边缘仍然是平滑的。在动画中，视差的缺乏暴露了凸起，无论多么真实，实际上只是“画”在表面上。

纹理不仅可以用于阴影，还可以用于改变几何形状。位移图是这个想法的最简单的版本之一。其概念与凹凸图相同：一个标量(单通道)地图，给出高于“平均地形”的高度。但效果是不同的。与从高度图中提取法线的同时仍然使用光滑的表面不同，位移图实际上改变了表面，将每个点沿着光滑表面的法线移动到一个新的位置。法线在 2 种情况下都大致相同，但表面是不同的。

实现置换贴图最常见的方法是用大量的小三角形对光滑表面进行镶嵌，然后用置换贴图置换生成的网格的顶点。在图形管道中，这可以在顶点阶段使用纹理查找来完成，对于地形来说特别方便。

### 11.4.4 阴影贴图

阴影是场景中物体关系的重要线索，正如我们所看到的，阴影很容易包含在光线追踪图像中。然而，如何在栅格化渲染中获得阴影并不简单，因为表面是一次单独考虑一个几何体。阴影贴图是一种利用纹理贴图的机制从点光源中获得阴影的技术。

阴影贴图的概念是表示被点光源照亮的空间体积。把光源想象成聚光灯或视频投影仪，它们从一个点向有限范围的方向发射光。被照亮的体积是线段的结合，将光源连接到最近的表面点，沿着每条离开该点的光线。
![](pic/Pasted%20image%2020240319191950.png)
有趣的是，这个体积与位于光源同一点的透视相机可见的体积相同：当且仅当一个点可以从从光源位置看到时，这个点会被光源照亮。在两种情况下，需要评估场景中点的可见性：

1. 对于片元对摄像机的可见性，我们需要知道相机是否可以看到片元，需要知道是否要将其绘制在图像中；
2. 对于阴影贴图，我们需要知道片元是否对光源可见，以了解它是否被光源照明。

在这两种情况下，解决方案都是相同的：深度图，它告诉我们沿一束光线到最近表面的距离。
在摄像机的可见性情况下，这是 z 缓冲区，对于阴影情况，它称为阴影贴图。在这两种情况下，可见性是通过比较新片元的深度和纹理中存储的深度来评估的。如果表面的深度大于最近可见表面的深度，则表面从投影点隐藏(遮挡或阴影)。
不同之处在于，z 缓冲区用于跟踪迄今为止所见的最接近的表面，并且在渲染期间被更新，而阴影贴图告诉到整个场景中最近表面的距离。

阴影贴图提前在单独的渲染通道中计算：简单地像往常一样栅格化整个场景，并保留结果的深度贴图(不需要计算色彩)。然后，利用手中的阴影贴图，执行普通的渲染过程。当您需要知道片元对光源是否可见时，你可以将片元投影到阴影贴图中(使用最初用于渲染阴影贴图的相同透视投影)，然后对比贴图中存储的深度值（距离光源最近的表面）。如果距离相同，则照亮片元，如果 d > dmap，这意味着有另一个表面更接近源，所以它是阴影。

“如果距离相同”这句话应该会在你的脑海中引起一些危险信号：因为所有涉及的数量都是有限精度的近似值，我们不能期望它们完全相同。对于可见点，d≈dmap，但 d 有时会大一点，有时会小一点。因此，需要一个公差 d - dmap <e。这种容忍度被称为阴影偏差。

当查看阴影贴图时，在贴图中记录的深度值之间进行插值并没有多大意义。这可能会在平滑区域产生更准确的深度(需要更少的阴影偏差)，但在阴影边界附近会产生更大的问题，因为深度值会突然变化。
因此，阴影贴图中的纹理查找是使用最近邻重建完成的。为了减少混叠，可以使用多个样本，对 1 或 0 的阴影结果(而不是深度)进行平均——这被称为百分比邻近过滤。

### 11.4.5 环境贴图

就像纹理可以方便地将细节引入表面上的着色而无需向模型添加更多细节一样，纹理也可以用于将细节引入照明而无需建模复杂几何形状的光源。当光线来自较远的地方时，与视野中物体的大小相比，场景中点与点之间的照明变化很小。假设照明只取决于你看的方向，并且场景中所有点受到的照明都是相同的，然后使用环境贴图来表达照明对方向的依赖，这是很方便的。

环境贴图的理念是，在 3D 中定义在单位球体上的函数，所以它可以用纹理贴图来表示，就像我们在球形物体上表示颜色变化一样。我们不是从表面点的 3D 坐标计算纹理坐标，而是使用完全相同的公式从单位矢量的 3D 坐标计算纹理坐标，单位矢量表示我们想要知道照明的方向。

环境贴图最简单的应用是在光线追踪器中给不会击中任何物体的光线赋予颜色

通过对光线追踪器的更改，反射其他场景对象的闪亮物体现在也会反射背景环境。

类似的效果可以通过在光栅化环境中添加镜像反射来实现，这与在光线追踪器中计算的方式相同，但只是直接在环境贴图中查找，而不考虑场景中的其他物体：
![](pic/Pasted%20image%2020240319201504.png)
这种技术被称为反射映射。

环境贴图的一个更高级的用途是计算来自环境贴图的所有照明，而不仅仅是镜面反射。叫做环境关照，可以在光线跟踪器中使用蒙特卡罗积分或在光栅化渲染中使用点源的集合近似环境并计算许多阴影图。

环境地图可以存储在任何可以用于映射球体的坐标中。球面坐标是一种流行的选择，尽管在极点压缩纹理会浪费纹理分辨率，并可能在极点产生伪影。Cubemaps 是一种更有效的选择，广泛用于交互式应用程序。
![](pic/Pasted%20image%2020240319202252.png)

## 11.5 程序化 3D 纹理

在前面的章节中，我们使用 cr 作为对象上一个点的漫反射。对于没有固体颜色的对象，我们可以用函数 cr (p)替换它，该函数将 3D 点映射到 RGB 颜色。这个函数可能只是返回包含 p 的对象反射率。但是对于具有纹理的对象，我们应该期望 cr(p) 会随着 p 在表面移动而变化。

定义从 3D 表面映射到 2D 纹理域的纹理映射函数的另一种方法是创建一个 3D 纹理，该纹理定义了 3D 空间中每个点的 RGB 值。我们只为那些位于表面上的点 p 调用这个纹理，但是为 3D 空间中所有的点定义纹理远比为某个潜在的怪异 2D 任意曲面定义纹理要简单得多。关于 3D 纹理映射的一个好消息是它很容易定义映射函数，因为表面已经嵌入到 3D 空间中，并且从 3D 到纹理空间的映射没有扭曲。这样的策略显然适用于固体介质中“雕刻”的表面，例如大理石雕塑。

3D 纹理的缺点是将它们存储为 3D 栅格图像或体积会消耗大量内存。出于这个原因，3D 纹理坐标最常用于程序纹理，其中纹理值是使用数学过程计算的，而不是通过从纹理图像中查看它们。在本节中，我们将研究用于定义程序纹理的一些基本工具。这些也可用于定义 2D 程序纹理，尽管在 2D 中，使用光栅纹理图像更为常见。

### 11.5.1 3D 条纹纹理

有许多方法可以制作条纹纹理。假设我们有两种颜色 c0 和 c1，我们想用它来制作条纹颜色。我们需要一些振荡函数来在两种颜色之间切换。比如正弦函数：
如果我们想在条纹颜色之间平滑地插值，我们可以使用参数 t 线性变化颜色：
![](pic/Pasted%20image%2020240320094639.png)

### 11.5.2 实噪音

尽管条纹等规则纹理通常很有用，但我们希望能够制作“杂乱”的纹理。这通常是通过使用一种“实噪声”来完成的，也称 Perlin noise，因其发明者而得名。

通过为每个点调用随机数来获得嘈杂的外观是不合适的，因为它就像电视静态中的“白噪声”。我们希望在不损失随机质量的情况下使其更加平滑。
一种可能性是模糊白噪声，但没有实际的实现方法。
另一种可能性是在每个大格上取随机数，然后为大格点之间的新点插值这些随机点；这看起来仅仅只是一个前面提到的带有随机数的 3D 纹理数组。这种技术使栅格的区分太过于明显。

Perlin 使用各种技巧来改进这种基本的晶格技术，因此晶格不那么明显。这导致一组相当奇怪的步骤，但本质上只有三个改变。
第一个变化是使用 Hermite 插值来避免马赫带，就像对常规纹理所做的那样。
第二个变化是使用随机向量而不是值，用点积来推导随机数；这使得底层网格结构在视觉上不太明显，通过将局部最小值和最大值去除。
第三个变化是使用一维数组和散列来创建随机向量的虚拟 3D 数组。这增加了计算以降低内存使用。
![](pic/Pasted%20image%2020240320100955.png)

由于实噪声可以是正的，也可以是负的，因此必须对其进行变换。
暗曲线是原始噪声函数由正变为负的地方。由于噪声从 −1 到 1 变化，因此可以通过使用(噪声+ 1)/2 来实现更平滑的图像。然而，由于噪声值接近 1 或- 1 是罕见的，这将是一个相当平滑的图像。较大的缩放可以增加对比度。

### 11.5.3 湍流

![](pic/Pasted%20image%2020240320101521.png)
许多自然纹理在同一纹理中包含各种特征尺寸。Perlin 使用了伪分形“湍流”函数：
$$n_t(x)=\sum_i \frac{\vert n(2^ix) \vert}{2^i}$$
这有效地向湍流本身重复添加湍流函数的缩放副本
湍流也可以用来扭曲条纹函数
